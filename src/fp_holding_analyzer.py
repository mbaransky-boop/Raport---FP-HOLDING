"""
FP HOLDING Financial Analyzer
Analizator danych finansowych z Excela zgodnie z rzeczywistƒÖ strukturƒÖ i kolorami.
"""

import pandas as pd
import numpy as np
from datetime import datetime
from typing import Dict, List


class FPHoldingAnalyzer:
    """Analizator finansowy dla FP HOLDING wykorzystujƒÖcy rzeczywistƒÖ strukturƒô Excela"""
    
    def __init__(self, excel_path: str):
        self.excel_path = excel_path
        self.df = None
        self.analysis = {}
        
    def load_and_clean(self):
        """
        ≈Åaduje i czy≈õci dane z Excela ZACHOWUJƒÑC gotowƒÖ kolumnƒô ZYSK.
        
        Struktura Excela (kolory majƒÖ znaczenie!):
        - ZIELONE (przych√≥d): B, C, D (Obr√≥t brutto, Obr√≥t netto, VAT)
        - POMARA≈ÉCZOWE (koszty): E, F, G, H, I, J (Koszta brutto, Kwota netto, VAT, ZUS, PIT, Koszt pracowniczy)
        - ≈ª√ì≈ÅTE (zysk): K (ZYSK/Stra BRUTTO) - gotowa formu≈Ça =C-F-H-I-J
        """
        print(f"üìä ≈Åadujƒô dane z: {self.excel_path}")
        
        # Wczytaj dane od wrze≈õnia 2024 (pomijamy sierpie≈Ñ 2024)
        df = pd.read_excel(self.excel_path, nrows=14)
        
        # Usu≈Ñ pierwszy wiersz (sierpie≈Ñ 2024) - skupiamy siƒô na wrz.2024 - wrz.2025
        df = df.iloc[1:].reset_index(drop=True)
        
        print(f"‚úÖ Wczytano {len(df)} miesiƒôcy danych (wrz.2024 - wrz.2025)")
        print(f"üìã Kolumny: {list(df.columns)}")
        
        # KLUCZOWE: U≈ºyj gotowej kolumny ZYSK zamiast obliczaƒá od nowa!
        self.df = df.copy()
        
        # Zmie≈Ñ nazwy kolumn dla wygody (zachowujƒÖc semantykƒô)
        self.df.columns = [
            'Okres',  # A - data
            'Obr√≥t_brutto',  # B - ZIELONY (przych√≥d)
            'Obr√≥t_netto',   # C - ZIELONY (przych√≥d)
            'VAT_przych√≥d',  # D - ZIELONY (przych√≥d)
            'Koszta_brutto', # E - POMARA≈ÉCZOWY (koszt)
            'Kwota_netto',   # F - POMARA≈ÉCZOWY (koszt)
            'VAT_koszt',     # G - POMARA≈ÉCZOWY (koszt, formu≈Ça =E-F)
            'ZUS',           # H - POMARA≈ÉCZOWY (koszt)
            'PIT',           # I - POMARA≈ÉCZOWY (koszt)
            'Koszt_pracowniczy', # J - POMARA≈ÉCZOWY (koszt)
            'Zysk_Excel',    # K - ≈ª√ì≈ÅTY (zysk, formu≈Ça =C-F-H-I-J)
            '≈öredni_rachunek', # L
            'Ilo≈õƒá_rachunk√≥w'  # M
        ]
        
        # Konwersja dat - formatuj ≈Çadnie z polskimi nazwami miesiƒôcy
        import locale
        try:
            locale.setlocale(locale.LC_TIME, 'pl_PL.UTF-8')
        except:
            pass  # Je≈õli nie ma polskiej lokalizacji, u≈ºyj angielskiej
        
        self.df['Okres_str'] = pd.to_datetime(self.df['Okres']).dt.strftime('%b %Y')
        
        # Sumuj RZECZYWISTE koszty zgodnie z formu≈ÇƒÖ Excela
        self.df['Koszty_total'] = (
            self.df['Kwota_netto'] + 
            self.df['ZUS'] + 
            self.df['PIT'] + 
            self.df['Koszt_pracowniczy']
        )
        
        # Weryfikacja: czy nasz liczony zysk = zysk z Excela?
        self.df['Zysk_obliczony'] = (
            self.df['Obr√≥t_netto'] - 
            self.df['Koszty_total']
        )
        
        # Poka≈º r√≥≈ºnicƒô (powinna byƒá bliska 0)
        self.df['R√≥≈ºnica_zysk'] = abs(self.df['Zysk_Excel'] - self.df['Zysk_obliczony'])
        max_diff = self.df['R√≥≈ºnica_zysk'].max()
        
        if max_diff > 1:
            print(f"‚ö†Ô∏è  UWAGA: Maksymalna r√≥≈ºnica w zysku: {max_diff:.2f} z≈Ç")
        else:
            print(f"‚úÖ Weryfikacja zysku OK (max r√≥≈ºnica: {max_diff:.2f} z≈Ç)")
        
        print(f"\nüìä Podsumowanie danych:")
        print(f"  ‚Ä¢ Okres: {self.df['Okres_str'].iloc[0]} - {self.df['Okres_str'].iloc[-1]}")
        print(f"  ‚Ä¢ Przych√≥d netto: {self.df['Obr√≥t_netto'].sum():,.2f} z≈Ç")
        print(f"  ‚Ä¢ Koszty total: {self.df['Koszty_total'].sum():,.2f} z≈Ç")
        print(f"  ‚Ä¢ Zysk (Excel): {self.df['Zysk_Excel'].sum():,.2f} z≈Ç")
        
        return self
        
    def validate(self):
        """Walidacja danych"""
        print("\nüîç Walidacja danych...")
        
        issues = []
        
        # Sprawd≈∫ braki
        null_counts = self.df.isnull().sum()
        if null_counts.any():
            issues.append(f"BrakujƒÖce warto≈õci: {null_counts[null_counts > 0].to_dict()}")
        
        # Sprawd≈∫ ujemne przychody
        if (self.df['Obr√≥t_netto'] < 0).any():
            neg_revenue = self.df[self.df['Obr√≥t_netto'] < 0]
            issues.append(f"Ujemne przychody w miesiƒÖcach: {neg_revenue['Okres_str'].tolist()}")
        
        # Sprawd≈∫ ekstremalnie wysokie koszty
        avg_costs = self.df['Koszty_total'].mean()
        high_costs = self.df[self.df['Koszty_total'] > avg_costs * 2]
        if not high_costs.empty:
            print(f"‚ö†Ô∏è  MiesiƒÖce z kosztami >200% ≈õredniej:")
            for _, row in high_costs.iterrows():
                print(f"    {row['Okres_str']}: {row['Koszty_total']:,.0f} z≈Ç")
        
        if issues:
            print(f"‚ö†Ô∏è  Znalezione problemy: {len(issues)}")
            for issue in issues:
                print(f"    - {issue}")
        else:
            print("‚úÖ Dane poprawne")
        
        return self
        
    def analyze(self):
        """G≈Ç√≥wna analiza finansowa"""
        print("\nüìà Analiza finansowa...")
        
        # Podstawowe metryki
        total_revenue = self.df['Obr√≥t_netto'].sum()
        total_costs = self.df['Koszty_total'].sum()
        total_profit = self.df['Zysk_Excel'].sum()  # U≈ºywamy GOTOWEGO zysku!
        
        # Miesiƒôczne ≈õrednie
        avg_revenue = self.df['Obr√≥t_netto'].mean()
        avg_costs = self.df['Koszty_total'].mean()
        avg_profit = self.df['Zysk_Excel'].mean()
        
        # Mar≈ºa
        margin = (total_profit / total_revenue * 100) if total_revenue > 0 else 0
        
        # MiesiƒÖce z zyskiem vs stratƒÖ
        profitable_months = (self.df['Zysk_Excel'] > 0).sum()
        loss_months = (self.df['Zysk_Excel'] < 0).sum()
        
        # Najlepszy i najgorszy miesiƒÖc
        best_month = self.df.loc[self.df['Zysk_Excel'].idxmax()]
        worst_month = self.df.loc[self.df['Zysk_Excel'].idxmin()]
        
        # Trendy (ostatnie 3 vs pierwsze 3 miesiƒÖce)
        recent_avg = self.df.tail(3)['Zysk_Excel'].mean()
        initial_avg = self.df.head(3)['Zysk_Excel'].mean()
        trend = "rosnƒÖcy" if recent_avg > initial_avg else "spadajƒÖcy"
        
        self.analysis = {
            'summary': {
                'total_revenue': total_revenue,
                'total_costs': total_costs,
                'total_profit': total_profit,
                'avg_revenue': avg_revenue,
                'avg_costs': avg_costs,
                'avg_profit': avg_profit,
                'margin': margin,
                'profitable_months': profitable_months,
                'loss_months': loss_months,
                'trend': trend
            },
            'best_month': {
                'period': best_month['Okres_str'],
                'profit': best_month['Zysk_Excel'],
                'revenue': best_month['Obr√≥t_netto'],
                'costs': best_month['Koszty_total']
            },
            'worst_month': {
                'period': worst_month['Okres_str'],
                'profit': worst_month['Zysk_Excel'],
                'revenue': worst_month['Obr√≥t_netto'],
                'costs': worst_month['Koszty_total']
            },
            'costs_breakdown': {
                'kwota_netto': self.df['Kwota_netto'].sum(),
                'zus': self.df['ZUS'].sum(),
                'pit': self.df['PIT'].sum(),
                'koszt_pracowniczy': self.df['Koszt_pracowniczy'].sum()
            }
        }
        
        # Breakeven
        if avg_revenue > 0:
            breakeven_revenue = avg_costs
            current_revenue = avg_revenue
            breakeven_gap = current_revenue - breakeven_revenue
            
            self.analysis['breakeven'] = {
                'monthly_breakeven': breakeven_revenue,
                'current_revenue': current_revenue,
                'gap': breakeven_gap,
                'current_margin': margin,
                'status': 'above' if breakeven_gap > 0 else 'below'
            }
        
        print(f"‚úÖ Analiza uko≈Ñczona")
        print(f"  ‚Ä¢ Ca≈Çkowity przych√≥d: {total_revenue:,.0f} z≈Ç")
        print(f"  ‚Ä¢ Ca≈Çkowite koszty: {total_costs:,.0f} z≈Ç")
        print(f"  ‚Ä¢ Ca≈Çkowity zysk: {total_profit:,.0f} z≈Ç")
        print(f"  ‚Ä¢ Mar≈ºa: {margin:.2f}%")
        print(f"  ‚Ä¢ MiesiƒÖce z zyskiem: {profitable_months}/{len(self.df)}")
        
        return self
        
    def find_savings(self):
        """Identyfikacja mo≈ºliwo≈õci oszczƒôdno≈õci"""
        print("\nüí° Szukam mo≈ºliwo≈õci oszczƒôdno≈õci...")
        
        savings_opportunities = []
        
        # 1. ZUS - sprawd≈∫ wysokie p≈Çatno≈õci
        avg_zus = self.df['ZUS'].mean()
        high_zus = self.df[self.df['ZUS'] > avg_zus * 1.3]
        if not high_zus.empty:
            potential_zus_savings = (high_zus['ZUS'].mean() - avg_zus) * len(high_zus)
            savings_opportunities.append({
                'category': 'ZUS',
                'description': 'Wysokie p≈Çatno≈õci ZUS w niekt√≥rych miesiƒÖcach',
                'potential_savings': potential_zus_savings,
                'action': 'Sprawd≈∫ mo≈ºliwo≈õƒá preferencyjnego ZUS lub optymalizacji podstawy'
            })
        
        # 2. Koszty pracownicze - sprawd≈∫ fluktuacje
        avg_employee = self.df['Koszt_pracowniczy'].mean()
        high_employee = self.df[self.df['Koszt_pracowniczy'] > avg_employee * 1.5]
        if not high_employee.empty:
            potential_employee_savings = (high_employee['Koszt_pracowniczy'].mean() - avg_employee) * 0.2
            savings_opportunities.append({
                'category': 'Koszty pracownicze',
                'description': 'Wysokie wahania koszt√≥w pracowniczych',
                'potential_savings': potential_employee_savings * 12,
                'action': 'Optymalizacja zatrudnienia - rozwa≈º outsourcing lub czƒô≈õƒá etatu'
            })
        
        # 3. Kwota netto (g≈Ç√≥wny koszt) - miesiƒÖce z ekstremalnie wysokimi kosztami
        avg_kwota_netto = self.df['Kwota_netto'].mean()
        high_kwota = self.df[self.df['Kwota_netto'] > avg_kwota_netto * 1.5]
        if not high_kwota.empty:
            potential_kwota_savings = (high_kwota['Kwota_netto'].mean() - avg_kwota_netto) * 0.15
            savings_opportunities.append({
                'category': 'Kwota netto (g≈Ç√≥wne koszty)',
                'description': f'{len(high_kwota)} miesiƒÖce z kosztami >150% ≈õredniej',
                'potential_savings': potential_kwota_savings * 12,
                'action': 'Renegocjacja um√≥w z dostawcami, bulk pricing'
            })
        
        # 4. ≈öredni rachunek - optymalizacja
        if '≈öredni_rachunek' in self.df.columns:
            avg_receipt = self.df['≈öredni_rachunek'].mean()
            if avg_receipt > 0:
                upsell_potential = avg_receipt * 0.1 * self.df['Ilo≈õƒá_rachunk√≥w'].sum()
                savings_opportunities.append({
                    'category': 'Optymalizacja przychod√≥w',
                    'description': 'Zwiƒôkszenie ≈õredniego rachunku o 10%',
                    'potential_savings': upsell_potential,
                    'action': 'Upselling, cross-selling, pakiety'
                })
        
        self.analysis['savings'] = savings_opportunities
        
        total_potential = sum(s['potential_savings'] for s in savings_opportunities)
        print(f"‚úÖ Znaleziono {len(savings_opportunities)} mo≈ºliwo≈õci oszczƒôdno≈õci")
        print(f"  ‚Ä¢ Potencjalne oszczƒôdno≈õci roczne: {total_potential:,.0f} z≈Ç")
        
        return self
        
    def create_recovery_plan(self):
        """Tworzy plan naprawczy"""
        print("\nüéØ Tworzƒô plan naprawczy...")
        
        # Pobierz kluczowe dane
        avg_profit = self.analysis['summary']['avg_profit']
        margin = self.analysis['summary']['margin']
        loss_months = self.analysis['summary']['loss_months']
        
        recovery_plan = {
            'immediate': [],  # 0-30 dni
            'short_term': [],  # 1-3 miesiƒÖce
            'medium_term': [],  # 3-6 miesiƒôcy
            'long_term': []  # 6-12 miesiƒôcy
        }
        
        # IMMEDIATE (0-30 dni)
        if loss_months > 0:
            recovery_plan['immediate'].append({
                'action': 'Analiza miesiƒôcy stratnych',
                'description': f'{loss_months} miesiƒôcy ze stratƒÖ - zidentyfikuj przyczyny',
                'impact': 'Wysokie',
                'effort': 'Niskie'
            })
        
        recovery_plan['immediate'].append({
            'action': 'Cash flow emergency check',
            'description': 'Sprawd≈∫ zobowiƒÖzania US VAT (-50k), ZUS rata (-90k)',
            'impact': 'Krytyczne',
            'effort': 'Niskie'
        })
        
        # SHORT TERM (1-3 miesiƒÖce)
        if margin < 20:
            recovery_plan['short_term'].append({
                'action': 'Redukcja koszt√≥w o 10%',
                'description': 'Renegocjacja um√≥w, eliminacja marnotrawstwa',
                'impact': 'Wysokie',
                'effort': '≈örednie'
            })
        
        recovery_plan['short_term'].append({
            'action': 'Zwiƒôkszenie ≈õredniego rachunku',
            'description': 'Upselling, cross-selling - cel +10% do ≈õredniego rachunku',
            'impact': '≈örednie',
            'effort': 'Niskie'
        })
        
        # MEDIUM TERM (3-6 miesiƒôcy)
        recovery_plan['medium_term'].append({
            'action': 'Optymalizacja zatrudnienia',
            'description': 'Analiza koszt√≥w pracowniczych - outsourcing, automatyzacja',
            'impact': 'Wysokie',
            'effort': 'Wysokie'
        })
        
        recovery_plan['medium_term'].append({
            'action': 'Restrukturyzacja ZUS',
            'description': 'Uk≈Çad ratalny ZUS (-517k) - roz≈Ç√≥≈º na 24 miesiƒÖce',
            'impact': '≈örednie',
            'effort': '≈örednie'
        })
        
        # LONG TERM (6-12 miesiƒôcy)
        recovery_plan['long_term'].append({
            'action': 'Dywersyfikacja przychod√≥w',
            'description': 'Nowe ≈∫r√≥d≈Ça przychod√≥w, produkty premium',
            'impact': 'Wysokie',
            'effort': 'Wysokie'
        })
        
        recovery_plan['long_term'].append({
            'action': 'Optymalizacja podatkowa',
            'description': 'PrzeglƒÖd struktury podatkowej z doradcƒÖ',
            'impact': '≈örednie',
            'effort': '≈örednie'
        })
        
        self.analysis['recovery_plan'] = recovery_plan
        
        total_actions = sum(len(v) for v in recovery_plan.values())
        print(f"‚úÖ Plan naprawczy gotowy: {total_actions} dzia≈Ça≈Ñ")
        
        return self
        
    def export_to_csv(self, output_path: str):
        """Eksportuje oczyszczone dane do CSV"""
        export_df = self.df[[
            'Okres_str', 
            'Obr√≥t_brutto', 
            'Obr√≥t_netto', 
            'VAT_przych√≥d',
            'Koszta_brutto',
            'Kwota_netto',
            'ZUS',
            'PIT',
            '≈öredni_rachunek',
            'Ilo≈õƒá_rachunk√≥w',
            'Zysk_Excel'  # Eksportuj GOTOWY zysk z Excela!
        ]].copy()
        
        export_df.columns = [
            'Okres', 
            'Obr√≥t brutto', 
            'Obr√≥t netto', 
            'VAT',
            'Koszta brutto',
            'Kwota netto',
            'ZUS',
            'PIT',
            '≈öredni rachunek',
            'Ilo≈õƒá rachunk√≥w',
            'Zysk'
        ]
        
        export_df.to_csv(output_path, index=False, encoding='utf-8-sig')
        print(f"‚úÖ Dane wyeksportowane do: {output_path}")
        
        return self
